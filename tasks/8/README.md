# Вопрос 1

1a) Преобразование не требуется

1b) Числовое продвижение

1c) Не будет компилироваться из-за сужающего преобразования

1d) Числовое продвижение

1e) Чиловое преобразование

1f) Числовое продвижение

1g) Числовое преобразование

1h) Числовое преобразование

1i) Не будет компилироваться из-за сужающего преобразования

1j) Числовое преобразование

# Вопрос 2

[код](tasks/8/src/second.cpp)

# Вопрос 3

3a) "int 5" т.к. числовое продвижение short в int

3b) функции print() и print(int x=0) оба могут быть вызваны как print(), компилятор не может решить какую вызывать

3c) т.к. int может быть преобразован одновременно и в long и в double, компилятор не решить во что переводить

# Вопрос 4

При вызове count(1), компилятор создает экземпляр функции count<int>(int) и вызывает ее. Это вернет 1.

Когда count(1) вызывается снова, компилятор увидит, что count<int>(int) уже существует, и вызовет ее снова. Это вернет 2.

Когда вызывается count(2.3), компилятор создает экземпляр функции с прототипом count<double>(double) и вызывает ее. Это новая функция со своей собственной статической переменной c, поэтому она вернет 1.

Когда вызывается count(1), компилятор увидит, что мы явно запрашиваем версию double для count(). Эта функция уже существует из-за предыдущей инструкции, поэтому будет вызываться count<double>(double), и аргумент будет неявно преобразован до double. Эта функция вернет 2.

# Вопрос 5

[код](/tasks/7/src/fifth.cpp)
